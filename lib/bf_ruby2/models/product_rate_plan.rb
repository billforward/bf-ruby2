=begin
#BillForward REST API

#No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

OpenAPI spec version: 1.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.2.3-SNAPSHOT

=end

require 'date'

module Bfwd
  # A rate plan describes a pricing system under which a subscription can be made to a product.
  class ProductRatePlan
    # { \"description\" : \"The UTC DateTime when the object was created.\", \"verbs\":[] }
    attr_accessor :created

    # { \"description\" : \"ID of the user who last updated the entity.\", \"verbs\":[] }
    attr_accessor :changed_by

    # { \"description\" : \"The UTC DateTime when the object was last updated.\", \"verbs\":[] }
    attr_accessor :updated

    # { \"description\" : \"Add metadata.\", \"verbs\":[\"POST\"] }
    attr_accessor :metadata

    # {\"description\":\"ID uniquely identifying this rate plan.\",\"verbs\":[\"GET\"]}
    attr_accessor :id

    # {\"description\":\"Customer-relationship-management ID of the rate plan.\",\"verbs\":[\"GET\",\"PUT\",\"POST\"]}
    attr_accessor :crm_id

    # {\"description\":\"ID of the product to which this rate plan belongs. A product is essentially a collection of rate plans, and describes the service conferred to a customer upon subscription to any of said product's rate plans. The product serves also as a template from which its rate plans can infer default attributes.\",\"verbs\":[\"POST\",\"GET\"]}
    attr_accessor :product_id

    # {\"description\":\"The currency of the product-rate-plan &mdash; as specified by a three-character ISO 4217 currency code (i.e. USD).\",\"verbs\":[\"POST\",\"GET\"]}
    attr_accessor :currency

    # {\"default\":\"inclusive\",\"description\":\"The tax status of the product-rate-plan &mdash; either inclusive or exclusive.<br><span class=\\\"label label-default\\\">exclusive</span>pricing indicates that the cost of the Pricing Components do not include tax; when BillForward generates an Invoice, the tax will be calculated with this price as a base. <br>Tax-<span class=\\\"label label-default\\\">inclusive</span>pricing indicates that the Pricing components include Tax. BillForward will still calculate tax on each invoice. Tax will be calculated from the sales price.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}
    attr_accessor :tax_status

    # {\"default\":\"None\",\"description\":\"The action that should be taken, should an invoice for some subscription to this rate plan remain unpaid despite the dunning period's being exceeded.<br><span class=\\\"label label-default\\\">CancelSubscription</span> &mdash; Demotes the subscription to the `Failed` state as soon as the dunning period is exceeded.<br><span class=\\\"label label-default\\\">None</span> &mdash; The subscription is allowed to continue in the `AwaitingPayment` state indefinitely even if the dunning period is exceeded.For slow payment cycles &mdash; or when manual invoice remediation is common &mdash; <span class=\\\"label label-default\\\">None</span> is recommended.<br>In a heavily-automated SaaS environment, automatic cancellation via <span class=\\\"label label-default\\\">CancelSubscription</span> is recommended.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}
    attr_accessor :failed_payment_behaviour

    # {\"description\":\"Number of length-measures which constitute the rate plan's period. If left unspecified: the rate plan will use the same `duration` number as the Product to which it belongs.\",\"verbs\":[\"POST\",\"GET\"]}
    attr_accessor :duration

    # {\"description\":\"Measure describing the magnitude of the rate plan's period. If left unspecified: the rate plan will use the same `durationPeriod` magnitude as the Product to which it belongs.\",\"verbs\":[\"POST\",\"GET\"]}
    attr_accessor :duration_period

    # {\"default\":0,\"description\":\"Number of trial-length-measures which constitute the rate plan's trial period. If left unspecified: the rate plan will use the same `trial` number as the Product to which it belongs.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}
    attr_accessor :trial

    # {\"default\":\"none\",\"description\":\"Measure describing the magnitude of the rate plan's trial period. If left unspecified: the rate plan will use the same `trialPeriod` magnitude as the Product to which it belongs.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}
    attr_accessor :trial_period

    # {\"default\":\"recurring\",\"description\":\"The frequency of the rate plan &mdash; either recurring or non-recurring. If left unspecified: the rate plan will use the same `productType` frequency as the Product to which it belongs.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}
    attr_accessor :product_type

    # {\"default\":\"WithCoupon\",\"description\":\"The pro-rata mode for the rate plan. <br><span class=\\\"label label-default\\\">None</span> &mdash; The pro-rata cost for upgrades will be ignored.<br><span class=\\\"label label-default\\\">WithCoupon</span> &mdash; The pro-rata cost for upgrades will be calculated based on the time remaining for the subscription. Discounts from any attached coupons will be deducted from the pro-rated cost.<br><span class=\\\"label label-default\\\">WithoutCoupon</span> &mdash; The pro-rata cost for upgrades will be calculated based on the time remaining for the subscription. Discounts from any attached coupons will not be deducted from the pro-rated cost. \",\"verbs\":[]}
    attr_accessor :pro_rata_mode

    # {\"default\":\"true\",\"description\":\"Whether invoices are created if they have a zero valued cost before any discounts are applied.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"] }
    attr_accessor :create_zero_valued_invoices

    # {\"description\":\"A friendly name &mdash; for your benefit &mdash; used to identify this rate plan within some product in BillForward. The name should reflect the fact that this rate plan provides to the customer a price tiering system within which a subscription to its Product can be made. <br>The rate plan's name could describe the nature of its price tiering (e.g. \\\"Default pricing\\\", \\\"Student pricing\\\").<br>Remember also that rate plans can override the timing prescribed by their product. If your rate plan is defined by its overriding the default timing of its product, then that can be reflected in that rate plan's name. (e.g. \\\"Student pricing - Annual\\\").\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}
    attr_accessor :name

    # {\"description\":\"A friendly non-unique name used to identify this product-rate-plan\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}
    attr_accessor :public_name

    # {\"description\":\"The UTC DateTime specifying when the rate plan is valid from.\",\"verbs\":[\"GET\"]}
    attr_accessor :valid_from

    # {\"description\":\"The UTC DateTime specifying when the product-rate-plan is valid till.\",\"verbs\":[\"GET\"]}
    attr_accessor :valid_till

    # {\"description\":\"The current status of the rate plan.\",\"verbs\":[]}
    attr_accessor :status

    # {\"default\":\"CreditAccount\",\"description\":\"The action that should be taken, should the pro-rata calculation result in a negative value.<br><span class=\\\"label label-default\\\">NoCharge</span> &mdash; Don't return to the customer any money.<br><span class=\\\"label label-default\\\">CreditAccount</span> &mdash; Credit the customer's account with the amount.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}
    attr_accessor :migration_behaviour

    # {\"default\":\"<span class=\\\"label label-default\\\">Immediate</span>\",\"description\":\"The strategy for how invoices for this plan will be issued.<br><span class=\\\"label label-default\\\">Immediate</span> &mdash; All generated invoices move immediately to the 'Unpaid' state &mdash; beginning the payment pursuit process.<br><span class=\\\"label label-default\\\">Delayed</span> &mdash; All generated invoices begin in the 'Pending' state. An 'Issue Invoice' amendment is scheduled (based on the rate plan's `issueDuration` and `issuePeriod`) that will move the invoice to the 'Unpaid' state (beginning the payment pursuit process) in accordance with the rate plan's issuance schedule.<br><span class=\\\"label label-default\\\">Manual</span> &mdash; All generated invoices sit in the 'Pending' state &mdash; they will not be issued to the customer unless explicit action is taken. This gives you an opportunity to review or recalculate the invoice.\"verbs\":[\"POST\",\"GET\"]}
    attr_accessor :invoice_issue_type

    # {\"description\":\"Number of issue-length-measures between issuance of invoices for this rate plan.\"\"verbs\":[\"POST\",\"GET\"]}
    attr_accessor :issue_duration

    # {\"description\":\"Measure describing the magnitude of the invoice issuance period.\",\"verbs\":[\"POST\",\"GET\"]}
    attr_accessor :issue_period

    # {\"description\":\"A list linking taxation strategies to the rate plan.\",\"verbs\":[\"POST\",\"GET\",\"PUT\"]}
    attr_accessor :taxation

    # {\"description\":\"A list linking \\\"Fixed-Term Definitions\\\" to the rate plan.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}
    attr_accessor :fixed_term_definitions

    # {\"description\":\"The product to which this rate plan belongs. A product is essentially a collection of rate plans, and describes the service conferred to a customer upon subscription to any of said product's rate plans. The product serves also as a template from which its rate plans can infer default attributes.\",\"verbs\":[\"POST\",\"GET\"]}
    attr_accessor :product

    # {\"description\":\"The pricing-components which describe the price tiering system of this rate plan. A product rate plan may have 1 or more pricing components. Each pricing component represents a different charge associated with the subscription. Pricing components are versioned.\",\"verbs\":[\"POST\",\"PUT\",\"GET\"]}
    attr_accessor :pricing_components

    # {\"default\":\"(empty list)\",\"description\":\"List of AggregatingComponents &mdash; these describe pricing components whose prices should be recalculated upon invoice aggregation. For example: two subscriptions' individual consumptions may be neither of them large enough to achieve bulk-buy discounts. When aggregated, though, the same two subscriptions' consumption may add up to a quantity which does merit a bulk buy discount within your tiering system.\",\"verbs\":[\"POST\"]}
    attr_accessor :aggregating_components

    attr_accessor :payment_terms

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'created' => :'created',
        :'changed_by' => :'changedBy',
        :'updated' => :'updated',
        :'metadata' => :'metadata',
        :'id' => :'id',
        :'crm_id' => :'crmID',
        :'product_id' => :'productID',
        :'currency' => :'currency',
        :'tax_status' => :'taxStatus',
        :'failed_payment_behaviour' => :'failedPaymentBehaviour',
        :'duration' => :'duration',
        :'duration_period' => :'durationPeriod',
        :'trial' => :'trial',
        :'trial_period' => :'trialPeriod',
        :'product_type' => :'productType',
        :'pro_rata_mode' => :'proRataMode',
        :'create_zero_valued_invoices' => :'createZeroValuedInvoices',
        :'name' => :'name',
        :'public_name' => :'publicName',
        :'valid_from' => :'validFrom',
        :'valid_till' => :'validTill',
        :'status' => :'status',
        :'migration_behaviour' => :'migrationBehaviour',
        :'invoice_issue_type' => :'invoiceIssueType',
        :'issue_duration' => :'issueDuration',
        :'issue_period' => :'issuePeriod',
        :'taxation' => :'taxation',
        :'fixed_term_definitions' => :'fixedTermDefinitions',
        :'product' => :'product',
        :'pricing_components' => :'pricingComponents',
        :'aggregating_components' => :'aggregatingComponents',
        :'payment_terms' => :'paymentTerms'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'created' => :'DateTime',
        :'changed_by' => :'String',
        :'updated' => :'DateTime',
        :'metadata' => :'DynamicMetadata',
        :'id' => :'String',
        :'crm_id' => :'String',
        :'product_id' => :'String',
        :'currency' => :'String',
        :'tax_status' => :'String',
        :'failed_payment_behaviour' => :'String',
        :'duration' => :'Integer',
        :'duration_period' => :'String',
        :'trial' => :'Integer',
        :'trial_period' => :'String',
        :'product_type' => :'String',
        :'pro_rata_mode' => :'String',
        :'create_zero_valued_invoices' => :'BOOLEAN',
        :'name' => :'String',
        :'public_name' => :'String',
        :'valid_from' => :'DateTime',
        :'valid_till' => :'DateTime',
        :'status' => :'String',
        :'migration_behaviour' => :'String',
        :'invoice_issue_type' => :'String',
        :'issue_duration' => :'Integer',
        :'issue_period' => :'String',
        :'taxation' => :'Array<MutableBillingEntity>',
        :'fixed_term_definitions' => :'Array<MutableBillingEntity>',
        :'product' => :'Product',
        :'pricing_components' => :'Array<PricingComponent>',
        :'aggregating_components' => :'Array<AggregatingComponent>',
        :'payment_terms' => :'Integer'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes.has_key?(:'created')
        self.created = attributes[:'created']
      end

      if attributes.has_key?(:'changedBy')
        self.changed_by = attributes[:'changedBy']
      end

      if attributes.has_key?(:'updated')
        self.updated = attributes[:'updated']
      end

      if attributes.has_key?(:'metadata')
        self.metadata = attributes[:'metadata']
      end

      if attributes.has_key?(:'id')
        self.id = attributes[:'id']
      end

      if attributes.has_key?(:'crmID')
        self.crm_id = attributes[:'crmID']
      end

      if attributes.has_key?(:'productID')
        self.product_id = attributes[:'productID']
      end

      if attributes.has_key?(:'currency')
        self.currency = attributes[:'currency']
      end

      if attributes.has_key?(:'taxStatus')
        self.tax_status = attributes[:'taxStatus']
      end

      if attributes.has_key?(:'failedPaymentBehaviour')
        self.failed_payment_behaviour = attributes[:'failedPaymentBehaviour']
      end

      if attributes.has_key?(:'duration')
        self.duration = attributes[:'duration']
      end

      if attributes.has_key?(:'durationPeriod')
        self.duration_period = attributes[:'durationPeriod']
      end

      if attributes.has_key?(:'trial')
        self.trial = attributes[:'trial']
      end

      if attributes.has_key?(:'trialPeriod')
        self.trial_period = attributes[:'trialPeriod']
      end

      if attributes.has_key?(:'productType')
        self.product_type = attributes[:'productType']
      end

      if attributes.has_key?(:'proRataMode')
        self.pro_rata_mode = attributes[:'proRataMode']
      end

      if attributes.has_key?(:'createZeroValuedInvoices')
        self.create_zero_valued_invoices = attributes[:'createZeroValuedInvoices']
      else
        self.create_zero_valued_invoices = false
      end

      if attributes.has_key?(:'name')
        self.name = attributes[:'name']
      end

      if attributes.has_key?(:'publicName')
        self.public_name = attributes[:'publicName']
      end

      if attributes.has_key?(:'validFrom')
        self.valid_from = attributes[:'validFrom']
      end

      if attributes.has_key?(:'validTill')
        self.valid_till = attributes[:'validTill']
      end

      if attributes.has_key?(:'status')
        self.status = attributes[:'status']
      end

      if attributes.has_key?(:'migrationBehaviour')
        self.migration_behaviour = attributes[:'migrationBehaviour']
      end

      if attributes.has_key?(:'invoiceIssueType')
        self.invoice_issue_type = attributes[:'invoiceIssueType']
      end

      if attributes.has_key?(:'issueDuration')
        self.issue_duration = attributes[:'issueDuration']
      end

      if attributes.has_key?(:'issuePeriod')
        self.issue_period = attributes[:'issuePeriod']
      end

      if attributes.has_key?(:'taxation')
        if (value = attributes[:'taxation']).is_a?(Array)
          self.taxation = value
        end
      end

      if attributes.has_key?(:'fixedTermDefinitions')
        if (value = attributes[:'fixedTermDefinitions']).is_a?(Array)
          self.fixed_term_definitions = value
        end
      end

      if attributes.has_key?(:'product')
        self.product = attributes[:'product']
      end

      if attributes.has_key?(:'pricingComponents')
        if (value = attributes[:'pricingComponents']).is_a?(Array)
          self.pricing_components = value
        end
      end

      if attributes.has_key?(:'aggregatingComponents')
        if (value = attributes[:'aggregatingComponents']).is_a?(Array)
          self.aggregating_components = value
        end
      end

      if attributes.has_key?(:'paymentTerms')
        self.payment_terms = attributes[:'paymentTerms']
      end

    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properies with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if @product_id.nil?
        invalid_properties.push("invalid value for 'product_id', product_id cannot be nil.")
      end

      if @currency.nil?
        invalid_properties.push("invalid value for 'currency', currency cannot be nil.")
      end

      if @tax_status.nil?
        invalid_properties.push("invalid value for 'tax_status', tax_status cannot be nil.")
      end

      if @failed_payment_behaviour.nil?
        invalid_properties.push("invalid value for 'failed_payment_behaviour', failed_payment_behaviour cannot be nil.")
      end

      if @duration_period.nil?
        invalid_properties.push("invalid value for 'duration_period', duration_period cannot be nil.")
      end

      if @pro_rata_mode.nil?
        invalid_properties.push("invalid value for 'pro_rata_mode', pro_rata_mode cannot be nil.")
      end

      if @create_zero_valued_invoices.nil?
        invalid_properties.push("invalid value for 'create_zero_valued_invoices', create_zero_valued_invoices cannot be nil.")
      end

      if @name.nil?
        invalid_properties.push("invalid value for 'name', name cannot be nil.")
      end

      if @migration_behaviour.nil?
        invalid_properties.push("invalid value for 'migration_behaviour', migration_behaviour cannot be nil.")
      end

      if @pricing_components.nil?
        invalid_properties.push("invalid value for 'pricing_components', pricing_components cannot be nil.")
      end

      return invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @product_id.nil?
      return false if @currency.nil?
      return false if @tax_status.nil?
      tax_status_validator = EnumAttributeValidator.new('String', ["inclusive", "exclusive"])
      return false unless tax_status_validator.valid?(@tax_status)
      return false if @failed_payment_behaviour.nil?
      failed_payment_behaviour_validator = EnumAttributeValidator.new('String', ["CancelSubscription", "None"])
      return false unless failed_payment_behaviour_validator.valid?(@failed_payment_behaviour)
      return false if @duration_period.nil?
      duration_period_validator = EnumAttributeValidator.new('String', ["minutes", "days", "months", "years"])
      return false unless duration_period_validator.valid?(@duration_period)
      trial_period_validator = EnumAttributeValidator.new('String', ["none", "minutes", "days", "months"])
      return false unless trial_period_validator.valid?(@trial_period)
      product_type_validator = EnumAttributeValidator.new('String', ["nonrecurring", "recurring"])
      return false unless product_type_validator.valid?(@product_type)
      return false if @pro_rata_mode.nil?
      pro_rata_mode_validator = EnumAttributeValidator.new('String', ["None", "WithCoupon", "WithoutCoupon", "Full"])
      return false unless pro_rata_mode_validator.valid?(@pro_rata_mode)
      return false if @create_zero_valued_invoices.nil?
      return false if @name.nil?
      return false if @migration_behaviour.nil?
      migration_behaviour_validator = EnumAttributeValidator.new('String', ["NoCharge", "CreditAccount"])
      return false unless migration_behaviour_validator.valid?(@migration_behaviour)
      invoice_issue_type_validator = EnumAttributeValidator.new('String', ["Immediate", "Delayed", "Manual"])
      return false unless invoice_issue_type_validator.valid?(@invoice_issue_type)
      issue_period_validator = EnumAttributeValidator.new('String', ["minutes", "days", "months", "years"])
      return false unless issue_period_validator.valid?(@issue_period)
      return false if @pricing_components.nil?
      return true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] tax_status Object to be assigned
    def tax_status=(tax_status)
      validator = EnumAttributeValidator.new('String', ["inclusive", "exclusive"])
      unless validator.valid?(tax_status)
        fail ArgumentError, "invalid value for 'tax_status', must be one of #{validator.allowable_values}."
      end
      @tax_status = tax_status
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] failed_payment_behaviour Object to be assigned
    def failed_payment_behaviour=(failed_payment_behaviour)
      validator = EnumAttributeValidator.new('String', ["CancelSubscription", "None"])
      unless validator.valid?(failed_payment_behaviour)
        fail ArgumentError, "invalid value for 'failed_payment_behaviour', must be one of #{validator.allowable_values}."
      end
      @failed_payment_behaviour = failed_payment_behaviour
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] duration_period Object to be assigned
    def duration_period=(duration_period)
      validator = EnumAttributeValidator.new('String', ["minutes", "days", "months", "years"])
      unless validator.valid?(duration_period)
        fail ArgumentError, "invalid value for 'duration_period', must be one of #{validator.allowable_values}."
      end
      @duration_period = duration_period
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] trial_period Object to be assigned
    def trial_period=(trial_period)
      validator = EnumAttributeValidator.new('String', ["none", "minutes", "days", "months"])
      unless validator.valid?(trial_period)
        fail ArgumentError, "invalid value for 'trial_period', must be one of #{validator.allowable_values}."
      end
      @trial_period = trial_period
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] product_type Object to be assigned
    def product_type=(product_type)
      validator = EnumAttributeValidator.new('String', ["nonrecurring", "recurring"])
      unless validator.valid?(product_type)
        fail ArgumentError, "invalid value for 'product_type', must be one of #{validator.allowable_values}."
      end
      @product_type = product_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] pro_rata_mode Object to be assigned
    def pro_rata_mode=(pro_rata_mode)
      validator = EnumAttributeValidator.new('String', ["None", "WithCoupon", "WithoutCoupon", "Full"])
      unless validator.valid?(pro_rata_mode)
        fail ArgumentError, "invalid value for 'pro_rata_mode', must be one of #{validator.allowable_values}."
      end
      @pro_rata_mode = pro_rata_mode
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] migration_behaviour Object to be assigned
    def migration_behaviour=(migration_behaviour)
      validator = EnumAttributeValidator.new('String', ["NoCharge", "CreditAccount"])
      unless validator.valid?(migration_behaviour)
        fail ArgumentError, "invalid value for 'migration_behaviour', must be one of #{validator.allowable_values}."
      end
      @migration_behaviour = migration_behaviour
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] invoice_issue_type Object to be assigned
    def invoice_issue_type=(invoice_issue_type)
      validator = EnumAttributeValidator.new('String', ["Immediate", "Delayed", "Manual"])
      unless validator.valid?(invoice_issue_type)
        fail ArgumentError, "invalid value for 'invoice_issue_type', must be one of #{validator.allowable_values}."
      end
      @invoice_issue_type = invoice_issue_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] issue_period Object to be assigned
    def issue_period=(issue_period)
      validator = EnumAttributeValidator.new('String', ["minutes", "days", "months", "years"])
      unless validator.valid?(issue_period)
        fail ArgumentError, "invalid value for 'issue_period', must be one of #{validator.allowable_values}."
      end
      @issue_period = issue_period
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          created == o.created &&
          changed_by == o.changed_by &&
          updated == o.updated &&
          metadata == o.metadata &&
          id == o.id &&
          crm_id == o.crm_id &&
          product_id == o.product_id &&
          currency == o.currency &&
          tax_status == o.tax_status &&
          failed_payment_behaviour == o.failed_payment_behaviour &&
          duration == o.duration &&
          duration_period == o.duration_period &&
          trial == o.trial &&
          trial_period == o.trial_period &&
          product_type == o.product_type &&
          pro_rata_mode == o.pro_rata_mode &&
          create_zero_valued_invoices == o.create_zero_valued_invoices &&
          name == o.name &&
          public_name == o.public_name &&
          valid_from == o.valid_from &&
          valid_till == o.valid_till &&
          status == o.status &&
          migration_behaviour == o.migration_behaviour &&
          invoice_issue_type == o.invoice_issue_type &&
          issue_duration == o.issue_duration &&
          issue_period == o.issue_period &&
          taxation == o.taxation &&
          fixed_term_definitions == o.fixed_term_definitions &&
          product == o.product &&
          pricing_components == o.pricing_components &&
          aggregating_components == o.aggregating_components &&
          payment_terms == o.payment_terms
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [created, changed_by, updated, metadata, id, crm_id, product_id, currency, tax_status, failed_payment_behaviour, duration, duration_period, trial, trial_period, product_type, pro_rata_mode, create_zero_valued_invoices, name, public_name, valid_from, valid_till, status, migration_behaviour, invoice_issue_type, issue_duration, issue_period, taxation, fixed_term_definitions, product, pricing_components, aggregating_components, payment_terms].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = Bfwd.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
